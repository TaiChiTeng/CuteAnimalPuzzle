# CuteAnimalPuzzle 代码规范文档

## 项目基本信息

- **项目名称**: CuteAnimalPuzzle
- **引擎版本**: Cocos Creator 3.8.6
- **开发语言**: TypeScript
- **目标平台**: 微信小游戏
- **TypeScript配置**: 基于 Cocos Creator 默认配置，strict 模式关闭

## 1. TypeScript 编码规范

### 1.1 基本语法规范

#### 变量命名
```typescript
// ✅ 推荐：使用 camelCase 命名变量和函数
let puzzleCount: number = 0;
let currentDifficulty: PuzzleDifficulty;
function getPuzzleStatus(): PuzzleStatus { }

// ✅ 推荐：使用 PascalCase 命名类和接口
class GameDataPuzzle { }
interface IPuzzleData { }

// ✅ 推荐：使用 UPPER_SNAKE_CASE 命名常量
const MAX_PUZZLE_COUNT: number = 100;
const DEFAULT_VOLUME: number = 1.0;

// ✅ 推荐：使用 PascalCase 命名枚举
enum PuzzleStatus {
    UNAVAILABLE = 0,
    LOCKED = 1,
    UNLOCKED = 2,
    COMPLETED = 3
}
```

#### 类型注解
```typescript
// ✅ 推荐：明确的类型注解
function setPuzzleStatus(puzzleId: number, status: PuzzleStatus): void {
    // 实现逻辑
}

// ✅ 推荐：使用接口定义复杂对象
interface PuzzleConfig {
    id: number;
    groupId: number;
    difficulty: PuzzleDifficulty;
    imageUrl: string;
}

// ✅ 推荐：使用泛型提高代码复用性
class ResourceCache<T> {
    private cache: Map<string, T> = new Map();
    
    get(key: string): T | null {
        return this.cache.get(key) || null;
    }
}
```

### 1.2 Cocos Creator 特定规范

#### 组件属性声明
```typescript
// ✅ 推荐：使用 @property 装饰器声明组件属性
@ccclass('UIMainMenu')
export class UIMainMenu extends Component {
    @property(Button)
    playButton: Button = null!;
    
    @property(ProgressBar)
    loadingProgress: ProgressBar = null!;
    
    @property({ type: CCFloat, tooltip: "加载时间（秒）" })
    loadTime: number = 2.0;
    
    @property({ type: Node, tooltip: "声音按钮节点" })
    soundButton: Node = null!;
}
```

#### 生命周期方法
```typescript
// ✅ 推荐：按照生命周期顺序排列方法
@ccclass('PuzzlePiece')
export class PuzzlePiece extends Component {
    // 属性声明
    @property(Sprite)
    pieceSprite: Sprite = null!;
    
    // 私有变量
    private _pieceIndex: number = -1;
    private _correctRow: number = -1;
    private _correctCol: number = -1;
    
    // 生命周期方法
    protected onLoad(): void {
        // 初始化逻辑
    }
    
    protected start(): void {
        // 启动逻辑
    }
    
    protected update(deltaTime: number): void {
        // 更新逻辑
    }
    
    protected onDestroy(): void {
        // 清理逻辑
    }
    
    // 公共方法
    public setPieceInfo(index: number, correctRow: number, correctCol: number): void {
        this._pieceIndex = index;
        this._correctRow = correctRow;
        this._correctCol = correctCol;
    }
    
    // 私有方法
    private updatePiecePosition(): void {
        // 私有实现
    }
}
```

### 1.3 单例模式规范

```typescript
// ✅ 推荐：标准单例模式实现
export class GameDataPuzzle {
    private static _instance: GameDataPuzzle | null = null;
    
    // 私有构造函数
    private constructor() {
        this.initializeData();
    }
    
    // 单例获取方法
    public static get instance(): GameDataPuzzle {
        if (!this._instance) {
            this._instance = new GameDataPuzzle();
        }
        return this._instance;
    }
    
    // 销毁单例（用于测试或重置）
    public static destroyInstance(): void {
        this._instance = null;
    }
    
    private initializeData(): void {
        // 初始化逻辑
    }
}
```

## 2. 文件组织规范

### 2.1 目录结构
```
assets/
├── CuteAnimalPuzzle/
│   ├── GameScripts/          # 游戏核心逻辑
│   │   ├── GameDataPuzzle.ts
│   │   ├── UIManager.ts
│   │   ├── PuzzleResourceManager.ts
│   │   └── ...
│   ├── Prefabs/              # 预制体文件
│   ├── Scenes/               # 场景文件
│   ├── Textures/             # 纹理资源
│   └── Audio/                # 音频资源
├── Scripts/                  # 通用脚本
│   ├── Loading.ts
│   ├── wxManager.ts
│   └── wx.d.ts
└── Resources/                # 动态加载资源
```

### 2.2 文件命名规范
```typescript
// ✅ 推荐：文件名使用 PascalCase
GameDataPuzzle.ts
UIManager.ts
PuzzleResourceManager.ts

// ✅ 推荐：组件文件以功能命名
UISolvePuzzle.ts      // UI相关组件
PuzzlePiece.ts        // 游戏逻辑组件
AudioMgr.ts           // 管理器类组件
```

### 2.3 导入导出规范
```typescript
// ✅ 推荐：明确的导入语句
import { _decorator, Component, Node, SpriteFrame, Sprite } from 'cc';
import { GameDataPuzzle, PuzzleStatus, PuzzleDifficulty } from './GameDataPuzzle';

// ✅ 推荐：使用命名导出
export class UIManager extends Component { }
export { PuzzleStatus, PuzzleDifficulty };

// ✅ 推荐：默认导出用于主要类
export default class PuzzleResourceManager { }
```

## 3. 注释规范

### 3.1 类和方法注释
```typescript
/**
 * 游戏数据管理类
 * 负责管理拼图游戏的存档数据、拼图状态、难度设置等
 * 采用单例模式，确保全局唯一实例
 */
export class GameDataPuzzle {
    /**
     * 获取指定拼图的状态
     * @param puzzleId 拼图ID
     * @returns 拼图状态枚举值
     */
    public getPuzzleStatus(puzzleId: number): PuzzleStatus {
        // 实现逻辑
    }
    
    /**
     * 异步加载拼图图片
     * @param puzzleId 拼图ID
     * @param url 图片URL地址
     * @returns Promise<SpriteFrame | null> 加载成功返回SpriteFrame，失败返回null
     */
    public async loadImageFromURL(puzzleId: number, url: string): Promise<SpriteFrame | null> {
        // 实现逻辑
    }
}
```

### 3.2 行内注释
```typescript
// ✅ 推荐：关键逻辑添加注释
public generatePuzzlePieces(puzzleId: number, rows: number, cols: number): SpriteFrame[] {
    const pieces: SpriteFrame[] = [];
    const totalPieces = rows * cols;
    
    // 获取原始拼图图片
    const originalTexture = this.getPuzzleSpriteFrame(puzzleId);
    if (!originalTexture) {
        console.warn(`无法找到拼图 ${puzzleId} 的纹理`);
        return pieces;
    }
    
    // 计算每个切片的尺寸
    const pieceWidth = originalTexture.width / cols;
    const pieceHeight = originalTexture.height / rows;
    
    // 生成所有切片
    for (let i = 0; i < totalPieces; i++) {
        // 计算当前切片在网格中的位置
        const row = Math.floor(i / cols);
        const col = i % cols;
        
        // 创建切片SpriteFrame
        const piece = this.createPieceFromTexture(originalTexture, col * pieceWidth, row * pieceHeight, pieceWidth, pieceHeight);
        pieces.push(piece);
    }
    
    return pieces;
}
```

## 4. 错误处理规范

### 4.1 异步操作错误处理
```typescript
// ✅ 推荐：使用 try-catch 处理异步错误
public async loadImageFromURL(puzzleId: number, url: string): Promise<SpriteFrame | null> {
    try {
        // 检查微信环境
        if (typeof wx === 'undefined') {
            console.warn('非微信环境，无法使用wx.downloadFile');
            return null;
        }
        
        const result = await this.downloadAndCacheImage(url);
        return result;
    } catch (error) {
        console.error(`加载拼图 ${puzzleId} 失败:`, error);
        return null;
    }
}
```

### 4.2 参数验证
```typescript
// ✅ 推荐：在方法开始处验证参数
public setPuzzleStatus(puzzleId: number, status: PuzzleStatus): void {
    // 参数验证
    if (puzzleId < 0) {
        console.error('拼图ID不能为负数');
        return;
    }
    
    if (!Object.values(PuzzleStatus).includes(status)) {
        console.error('无效的拼图状态值');
        return;
    }
    
    // 执行逻辑
    this._saveData.puzzleStatuses[puzzleId] = status;
    this.saveData();
}
```

## 5. 性能优化规范

### 5.1 对象池使用
```typescript
// ✅ 推荐：使用对象池管理频繁创建销毁的对象
export class PuzzlePiecePool {
    private static _pool: PuzzlePiece[] = [];
    
    public static getPiece(): PuzzlePiece {
        if (this._pool.length > 0) {
            return this._pool.pop()!;
        }
        
        // 创建新的拼图切片
        const piece = new PuzzlePiece();
        return piece;
    }
    
    public static returnPiece(piece: PuzzlePiece): void {
        // 重置切片状态
        piece.reset();
        this._pool.push(piece);
    }
}
```

### 5.2 资源管理
```typescript
// ✅ 推荐：及时释放不需要的资源
export class PuzzleResourceManager {
    private _textureCache: Map<number, SpriteFrame> = new Map();
    
    public clearCache(): void {
        // 释放所有缓存的纹理
        this._textureCache.forEach((texture, puzzleId) => {
            if (texture && texture.texture) {
                texture.texture.destroy();
            }
        });
        
        this._textureCache.clear();
        console.log('拼图资源缓存已清理');
    }
}
```

## 6. 微信小游戏特定规范

### 6.1 平台检测
```typescript
// ✅ 推荐：进行平台检测
function isWeChatMiniGame(): boolean {
    return typeof wx !== 'undefined' && wx.getSystemInfoSync;
}

// ✅ 推荐：使用平台守卫
public shareGame(): void {
    if (!isWeChatMiniGame()) {
        console.warn('当前不在微信小游戏环境中');
        return;
    }
    
    wx.shareAppMessage({
        title: '可爱动物拼图',
        query: 'from=share'
    });
}
```

### 6.2 文件系统使用
```typescript
// ✅ 推荐：正确使用微信文件系统
private async downloadAndCacheImage(url: string): Promise<SpriteFrame | null> {
    if (!isWeChatMiniGame()) {
        return null;
    }
    
    const fs = wx.getFileSystemManager();
    const fileName = this.getFileNameFromUrl(url);
    const localPath = `${wx.env.USER_DATA_PATH}/${fileName}`;
    
    try {
        // 检查本地文件是否存在
        fs.accessSync(localPath);
        console.log(`使用缓存文件: ${localPath}`);
        return await this.loadTextureFromLocalPath(localPath);
    } catch (error) {
        // 文件不存在，需要下载
        console.log(`下载新文件: ${url}`);
        return await this.downloadNewImage(url, localPath);
    }
}
```

## 7. 代码审查清单

### 7.1 提交前检查
- [ ] 所有公共方法都有适当的类型注解
- [ ] 关键逻辑都有注释说明
- [ ] 异步操作都有错误处理
- [ ] 没有使用 `any` 类型（除非必要）
- [ ] 组件属性都使用了 `@property` 装饰器
- [ ] 单例类正确实现了单例模式
- [ ] 微信API调用都有平台检测

### 7.2 性能检查
- [ ] 避免在 `update` 方法中进行重复计算
- [ ] 大型资源使用了延迟加载
- [ ] 不再使用的资源及时释放
- [ ] 使用对象池管理频繁创建的对象

### 7.3 兼容性检查
- [ ] 微信小游戏API使用正确
- [ ] 文件路径使用了正确的分隔符
- [ ] 资源加载考虑了网络异常情况
- [ ] UI适配了不同屏幕尺寸

## 8. 工具和配置

### 8.1 推荐的 VSCode 扩展
- TypeScript Importer
- Cocos Creator Extension
- ESLint
- Prettier

### 8.2 代码格式化配置
```json
// .prettierrc
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 4
}
```

## 版本信息

- **文档版本**: 1.0.0
- **适用引擎**: Cocos Creator 3.8.6
- **更新日期**: 2024年
- **维护者**: 开发团队